# フォールバック処理の禁止ルール

## 絶対に守ること

### フォールバック処理の禁止
- **禁止**: `value || fallback_value` のパターン
- **理由**: 根本的な問題を隠蔽し、技術的負債を蓄積する
- **例外**: 明示的に意図されたデフォルト値のみ

### 禁止パターンの例
```ruby
# ❌ 絶対にやるな
crop_id = plan_crop.agrr_crop_id || plan_crop.name
field_id = params[:field_id] || "field_#{field.id}"
allocation_id = fc.agrr_crop_id || fc.name
```

### 正しいパターン
```ruby
# ✅ 正しい実装
crop_id = plan_crop.agrr_crop_id
unless crop_id
  Rails.logger.error "❌ [AGRR] agrr_crop_id not found for plan_crop: #{plan_crop.name}"
  next
end

# ✅ 明示的なデフォルト値（意図的に設計された場合のみ）
daily_fixed_cost: field.daily_fixed_cost || 0.0
```

## フォールバック処理が生み出す問題

### 1. 技術的負債の蓄積
- 根本的な問題を隠蔽
- 対症療法的な解決策の連鎖
- コードの複雑化

### 2. 無駄な作業の連鎖
- フォールバック処理の実装
- 対症療法的な解決策の実装
- 問題の調査と分析
- 根本原因の修正
- 不要なコードの削除

### 3. 保守性の低下
- 複雑な条件分岐
- ハードコーディングされた変換テーブル
- テストの複雑化

## 実装の原則

### 1. データの整合性を保つ
- 不正なデータは適切にエラーハンドリング
- フォールバックで隠蔽しない

### 2. 明示的なエラーハンドリング
- データが存在しない場合は明確にエラーを出力
- ログに記録して問題を可視化

### 3. 根本原因の解決
- フォールバック処理で問題を隠蔽しない
- データの整合性を保つ

## 違反時の対応

### 1. 即座に修正
- フォールバック処理を削除
- 適切なエラーハンドリングを実装

### 2. 根本原因の調査
- なぜフォールバック処理が必要になったのかを調査
- データの整合性を確認

### 3. テストの追加
- 不正なデータに対する適切なエラーハンドリングをテスト
- フォールバック処理に依存しないテストを追加

## まとめ

**フォールバック処理は技術的負債の温床です。**
**根本的な問題を解決し、適切なエラーハンドリングを実装してください。**

---

**このルールを破った場合、以下の無駄な作業が発生します：**
1. フォールバック処理の実装（30分）
2. 対症療法的な解決策の実装（1時間）
3. 問題の調査と分析（2時間）
4. 根本原因の修正（1時間）
5. 不要なコードの削除（30分）

**総コスト: 5時間の無駄な作業**

**最初から正しく実装すれば、30分で完了します。**