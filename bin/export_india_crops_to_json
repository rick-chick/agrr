#!/usr/bin/env ruby
# frozen_string_literal: true

# Export India reference crops to JSON file

require 'fileutils'
require 'json'

require_relative '../config/environment'

# Logger with color output
class ColorLogger
  COLORS = {
    red: "\e[31m",
    green: "\e[32m",
    yellow: "\e[33m",
    blue: "\e[34m",
    reset: "\e[0m"
  }

  def self.log(message, color = :reset)
    puts "#{COLORS[color]}#{message}#{COLORS[:reset]}"
  end

  def self.info(message)
    log("‚ÑπÔ∏è  #{message}", :blue)
  end

  def self.success(message)
    log("‚úÖ #{message}", :green)
  end

  def self.warning(message)
    log("‚ö†Ô∏è  #{message}", :yellow)
  end

  def self.error(message)
    log("‚ùå #{message}", :red)
  end
end

# Header
ColorLogger.log("\n" + "=" * 80, :blue)
ColorLogger.log("Export India Reference Crops to JSON", :blue)
ColorLogger.log("=" * 80, :blue)
puts ""

# Get all India reference crops
ColorLogger.info("Loading India reference crops...")
crops = Crop.where(is_reference: true, region: 'in').order(:name)

if crops.empty?
  ColorLogger.error("No India reference crops found")
  exit 1
end

ColorLogger.success("Found #{crops.count} India reference crops")
puts ""

# Export to JSON
ColorLogger.info("Exporting to JSON format...")
output = {}

crops.each do |crop|
  unless crop.crop_stages.any?
    ColorLogger.warning("#{crop.name}: No stage information (skipped)")
    next
  end
  
  output[crop.name] = {
    name: crop.name,
    variety: crop.variety,
    is_reference: crop.is_reference,
    region: crop.region,
    area_per_unit: crop.area_per_unit,
    revenue_per_area: crop.revenue_per_area,
    groups: crop.groups,
    crop_stages: crop.crop_stages.order(:order).map do |stage|
      stage_hash = {
        name: stage.name,
        order: stage.order
      }
      
      if stage.temperature_requirement
        stage_hash[:temperature_requirement] = {
          base_temperature: stage.temperature_requirement.base_temperature,
          optimal_min: stage.temperature_requirement.optimal_min,
          optimal_max: stage.temperature_requirement.optimal_max,
          low_stress_threshold: stage.temperature_requirement.low_stress_threshold,
          high_stress_threshold: stage.temperature_requirement.high_stress_threshold,
          frost_threshold: stage.temperature_requirement.frost_threshold,
          sterility_risk_threshold: stage.temperature_requirement.sterility_risk_threshold,
          max_temperature: stage.temperature_requirement.max_temperature
        }
      end
      
      if stage.sunshine_requirement
        stage_hash[:sunshine_requirement] = {
          minimum_sunshine_hours: stage.sunshine_requirement.minimum_sunshine_hours,
          target_sunshine_hours: stage.sunshine_requirement.target_sunshine_hours
        }
      end
      
      if stage.thermal_requirement
        stage_hash[:thermal_requirement] = {
          required_gdd: stage.thermal_requirement.required_gdd
        }
      end
      
      stage_hash
    end
  }
  
  ColorLogger.success("#{crop.name}: Exported #{crop.crop_stages.count} stages")
end

if output.empty?
  ColorLogger.error("No data to export")
  exit 1
end

# Save to file
fixture_path = Rails.root.join('db/fixtures/india_reference_crops.json')
FileUtils.mkdir_p(File.dirname(fixture_path))
File.write(fixture_path, JSON.pretty_generate(output))

puts ""
ColorLogger.log("=" * 80, :green)
ColorLogger.success("Export Completed!")
ColorLogger.log("=" * 80, :green)
puts ""

puts "üìÑ Saved to: #{fixture_path}"
puts "üìä Crops: #{output.keys.count}"
puts "üìä Total stages: #{output.values.sum { |v| v[:crop_stages].count }}"
puts ""

ColorLogger.info("Next steps:")
puts "  1. Check the file: cat #{fixture_path} | head -n 100"
puts "  2. Verify English stage names: grep 'name' #{fixture_path} | head -n 50"
puts "  3. Commit to Git: git add #{fixture_path}"
puts "  4. After this, 'rails db:migrate' can quickly load the data"
puts ""

