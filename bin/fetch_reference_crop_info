#!/usr/bin/env ruby
# frozen_string_literal: true

# å‚ç…§ä½œç‰©ã®AIæƒ…å ±å–å¾—ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆAPIç‰ˆï¼‰
#
# ä½¿ç”¨æ–¹æ³•:
#   bin/fetch_reference_crop_info                        # å…¨å‚ç…§ä½œç‰©ã®æƒ…å ±ã‚’å–å¾—
#   bin/fetch_reference_crop_info --crop-name "ãƒˆãƒãƒˆ"    # ç‰¹å®šã®ä½œç‰©ã®ã¿
#   bin/fetch_reference_crop_info --api-url http://localhost:3000  # ã‚«ã‚¹ã‚¿ãƒ API URL
#
# å‰ææ¡ä»¶:
#   - rails db:seed ãŒå®Ÿè¡Œæ¸ˆã¿ï¼ˆå‚ç…§ä½œç‰©ãŒDBã«å­˜åœ¨ã™ã‚‹ï¼‰
#   - Webã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã‚‹ï¼ˆdocker compose up web ã¾ãŸã¯ rails serverï¼‰
#   - AI APIã‚­ãƒ¼ãŒè¨­å®šæ¸ˆã¿ï¼ˆç’°å¢ƒå¤‰æ•°: OPENAI_API_KEY ãªã©ï¼‰
#
# å‡¦ç†å†…å®¹:
#   1. DBã‹ã‚‰å‚ç…§ä½œç‰©ã‚’å–å¾—
#   2. å„ä½œç‰©ã«ã¤ã„ã¦ APIçµŒç”±ã§AIæƒ…å ±ã‚’å–å¾—ãƒ»ä¿å­˜
#   3. DBã‹ã‚‰å…¨ä½œç‰©ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚Šã€JSONã«å‡ºåŠ›
#   4. db/fixtures/reference_crops.json ã«ä¿å­˜

require 'fileutils'
require 'json'

require_relative '../config/environment'

# Railsã®ç’°å¢ƒã‚’èª­ã¿è¾¼ã‚“ã å¾Œã«net/httpã‚’ãƒ­ãƒ¼ãƒ‰
require 'net/http'
require 'uri'

# ãƒ­ã‚°å‡ºåŠ›ç”¨ã®ã‚«ãƒ©ãƒ¼å®šç¾©
class ColorLogger
  COLORS = {
    red: "\e[31m",
    green: "\e[32m",
    yellow: "\e[33m",
    blue: "\e[34m",
    reset: "\e[0m"
  }

  def self.log(message, color = :reset)
    puts "#{COLORS[color]}#{message}#{COLORS[:reset]}"
  end

  def self.info(message)
    log("â„¹ï¸  #{message}", :blue)
  end

  def self.success(message)
    log("âœ… #{message}", :green)
  end

  def self.warning(message)
    log("âš ï¸  #{message}", :yellow)
  end

  def self.error(message)
    log("âŒ #{message}", :red)
  end
end

# API Client
class AgrrApiClient
  def initialize(base_url)
    @base_url = base_url
  end

  def ai_create_crop(crop_name, variety = nil)
    uri = URI("#{@base_url}/api/v1/crops/ai_create")
    request = Net::HTTP::Post.new(uri)
    request['Content-Type'] = 'application/json'
    request.body = {
      name: crop_name,
      variety: variety
    }.to_json
    
    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == 'https') do |http|
      http.request(request)
    end
    
    JSON.parse(response.body)
  rescue => e
    { 'error' => e.message }
  end
end

# ã‚ªãƒ—ã‚·ãƒ§ãƒ³è§£æ
crop_name_filter = nil
api_url = 'http://localhost:3000'

ARGV.each_with_index do |arg, i|
  case arg
  when '--crop-name'
    crop_name_filter = ARGV[i + 1] if ARGV[i + 1]
  when '--api-url'
    api_url = ARGV[i + 1] if ARGV[i + 1]
  end
end

# ãƒ˜ãƒƒãƒ€ãƒ¼
ColorLogger.log("\n" + "=" * 60, :blue)
ColorLogger.log("å‚ç…§ä½œç‰©ã®AIæƒ…å ±å–å¾—ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆAPIç‰ˆï¼‰", :blue)
ColorLogger.log("=" * 60, :blue)
puts ""
ColorLogger.info("API URL: #{api_url}")
puts ""

# APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
api_client = AgrrApiClient.new(api_url)

# 1. DBã‹ã‚‰å‚ç…§ä½œç‰©ã‚’å–å¾—
ColorLogger.info("å‚ç…§ä½œç‰©ã‚’æ¤œç´¢ä¸­...")
crops = Crop.where(is_reference: true)
crops = crops.where(name: crop_name_filter) if crop_name_filter

if crops.empty?
  ColorLogger.error("å‚ç…§ä½œç‰©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å…ˆã« 'rails db:seed' ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
  exit 1
end

ColorLogger.success("#{crops.count}ä»¶ã®å‚ç…§ä½œç‰©ã‚’ç™ºè¦‹ã—ã¾ã—ãŸ")
puts ""

# 2. å„ä½œç‰©ã®AIæƒ…å ±ã‚’å–å¾—
crops.each_with_index do |crop, index|
  ColorLogger.log("\n[#{index + 1}/#{crops.count}] å‡¦ç†ä¸­: #{crop.name} (#{crop.variety})", :blue)
  
  # æ—¢ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  if crop.crop_stages.any?
    has_requirements = crop.crop_stages.all? do |stage|
      stage.temperature_requirement.present? ||
      stage.sunshine_requirement.present? ||
      stage.thermal_requirement.present?
    end
    
    if has_requirements
      ColorLogger.success("  AIæƒ…å ±å–å¾—æ¸ˆã¿ (#{crop.crop_stages.count}ã‚¹ãƒ†ãƒ¼ã‚¸)")
      next
    end
  end
  
  # APIçµŒç”±ã§AIæƒ…å ±ã‚’å–å¾—
  ColorLogger.info("  AIæƒ…å ±ã‚’å–å¾—ä¸­...")
  result = api_client.ai_create_crop(crop.name, crop.variety)
  
  if result['error']
    ColorLogger.warning("  AIã‚¨ãƒ©ãƒ¼: #{result['error']}")
    ColorLogger.warning("  ã“ã®ä½œç‰©ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
    next
  end
  
  if result['success']
    ColorLogger.success("  #{result['message']}")
    ColorLogger.info("  - ã‚¹ãƒ†ãƒ¼ã‚¸æ•°: #{result['stages_count']}")
    ColorLogger.info("  - æ ½åŸ¹é¢ç©: #{result['area_per_unit']} mÂ²")
    ColorLogger.info("  - åç›Šæ€§: Â¥#{result['revenue_per_area']}/mÂ²")
  else
    ColorLogger.warning("  AIæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: #{result['message']}")
  end
  
  # APIè² è·è»½æ¸›ã®ãŸã‚å¾…æ©Ÿ
  sleep 1
end

puts ""
ColorLogger.log("=" * 60, :blue)

# 3. DBã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚ŠJSONã«å¤‰æ›
ColorLogger.info("ãƒ‡ãƒ¼ã‚¿ã‚’JSONå½¢å¼ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...")
output = {}

crops.reload.each do |crop|
  unless crop.crop_stages.any?
    ColorLogger.warning("  #{crop.name}: ã‚¹ãƒ†ãƒ¼ã‚¸æƒ…å ±ãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰")
    next
  end
  
  output[crop.name] = {
    name: crop.name,
    variety: crop.variety,
    is_reference: crop.is_reference,
    area_per_unit: crop.area_per_unit,
    revenue_per_area: crop.revenue_per_area,
    groups: crop.groups,
    crop_stages: crop.crop_stages.order(:order).map do |stage|
      stage_hash = {
        name: stage.name,
        order: stage.order
      }
      
      if stage.temperature_requirement
        stage_hash[:temperature_requirement] = {
          base_temperature: stage.temperature_requirement.base_temperature,
          optimal_min: stage.temperature_requirement.optimal_min,
          optimal_max: stage.temperature_requirement.optimal_max,
          low_stress_threshold: stage.temperature_requirement.low_stress_threshold,
          high_stress_threshold: stage.temperature_requirement.high_stress_threshold,
          frost_threshold: stage.temperature_requirement.frost_threshold,
          sterility_risk_threshold: stage.temperature_requirement.sterility_risk_threshold,
          max_temperature: stage.temperature_requirement.max_temperature
        }
      end
      
      if stage.sunshine_requirement
        stage_hash[:sunshine_requirement] = {
          minimum_sunshine_hours: stage.sunshine_requirement.minimum_sunshine_hours,
          target_sunshine_hours: stage.sunshine_requirement.target_sunshine_hours
        }
      end
      
      if stage.thermal_requirement
        stage_hash[:thermal_requirement] = {
          required_gdd: stage.thermal_requirement.required_gdd
        }
      end
      
      stage_hash
    end
  }
  
  ColorLogger.success("  #{crop.name}: #{crop.crop_stages.count}ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ")
end

if output.empty?
  ColorLogger.error("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
  exit 1
end

# 4. ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
fixture_path = Rails.root.join('db/fixtures/reference_crops.json')
FileUtils.mkdir_p(File.dirname(fixture_path))
File.write(fixture_path, JSON.pretty_generate(output))

puts ""
ColorLogger.log("=" * 60, :green)
ColorLogger.success("å®Œäº†ï¼")
ColorLogger.log("=" * 60, :green)
puts ""
puts "ğŸ“„ ä¿å­˜å…ˆ: #{fixture_path}"
puts "ğŸ“Š ä½œç‰©æ•°: #{output.keys.count}"
puts "ğŸ“Š ç·ã‚¹ãƒ†ãƒ¼ã‚¸æ•°: #{output.values.sum { |v| v[:crop_stages].count }}"
puts ""
ColorLogger.info("æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:")
puts "  1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèª: cat #{fixture_path} | head -n 50"
puts "  2. Gitã«ã‚³ãƒŸãƒƒãƒˆ: git add #{fixture_path}"
puts "  3. ä»¥å¾Œã¯ 'rails db:seed' ã§é«˜é€Ÿã«ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ãŒå¯èƒ½ã«ãªã‚Šã¾ã™"
puts ""
