#!/usr/bin/env ruby
# frozen_string_literal: true

# India Reference Crops - Direct agrr command execution
# Fetch AI information and save to DB (Japanese stage names will be included)

require 'json'
require 'open3'

require_relative '../config/environment'

# Logger with color output
class ColorLogger
  COLORS = {
    red: "\e[31m",
    green: "\e[32m",
    yellow: "\e[33m",
    blue: "\e[34m",
    reset: "\e[0m"
  }

  def self.log(message, color = :reset)
    puts "#{COLORS[color]}#{message}#{COLORS[:reset]}"
  end

  def self.info(message)
    log("ℹ️  #{message}", :blue)
  end

  def self.success(message)
    log("✅ #{message}", :green)
  end

  def self.warning(message)
    log("⚠️  #{message}", :yellow)
  end

  def self.error(message)
    log("❌ #{message}", :red)
  end
end

# Fetch crop info from agrr daemon client (with retry logic)
def fetch_crop_info_from_agrr(crop_name, max_retries: 3)
  agrr_client_path = Rails.root.join('bin', 'agrr_client').to_s
  command = [
    agrr_client_path,
    'crop',
    '--query', crop_name,
    '--json'
  ]

  max_retries.times do |retry_count|
    attempt = retry_count + 1
    
    begin
      stdout, stderr, status = Open3.capture3(*command)

      unless status.success?
        error_msg = stderr.strip
        
        # 一時的なネットワークエラーや圧縮エラーの場合はリトライ
        if (error_msg.include?('decompressing') || error_msg.include?('Connection') || 
            error_msg.include?('timeout') || error_msg.include?('Network')) && attempt < max_retries
          
          sleep_time = 2 ** attempt
          ColorLogger.warning("Transient error (attempt #{attempt}/#{max_retries}): #{error_msg}. Retrying in #{sleep_time}s...")
          sleep(sleep_time)
          next
        end
        
        ColorLogger.error("agrr command failed after #{attempt} attempts: #{error_msg}")
        return nil
      end

      parsed_data = JSON.parse(stdout)
      
      if parsed_data['success'] == false
        ColorLogger.error("agrr returned error: #{parsed_data['error']}")
        return nil
      end
      
      if attempt > 1
        ColorLogger.success("Succeeded after #{attempt} attempts")
      end
      
      return parsed_data
      
    rescue JSON::ParserError => e
      ColorLogger.error("JSON parse error: #{e.message}")
      return nil
    rescue => e
      if attempt < max_retries
        sleep_time = 2 ** attempt
        ColorLogger.warning("Error (attempt #{attempt}/#{max_retries}): #{e.message}. Retrying in #{sleep_time}s...")
        sleep(sleep_time)
        next
      end
      
      ColorLogger.error("Error after #{attempt} attempts: #{e.message}")
      return nil
    end
  end
  
  ColorLogger.error("Failed to fetch crop info after #{max_retries} attempts")
  nil
end

# Save crop stages to DB
def save_crop_stages(crop, stages_data)
  saved_count = 0
  japanese_stages = []
  
  stages_data.each do |stage_requirement|
    stage_info = stage_requirement['stage']
    
    # Create CropStage
    stage = crop.crop_stages.create!(
      name: stage_info['name'],
      order: stage_info['order']
    )
    
    # Check for Japanese characters
    if stage.name =~ /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/
      japanese_stages << stage.name
    end
    
    # Temperature Requirement
    if stage_requirement['temperature'].present?
      temp_data = stage_requirement['temperature']
      stage.create_temperature_requirement!(
        base_temperature: temp_data['base_temperature'],
        optimal_min: temp_data['optimal_min'],
        optimal_max: temp_data['optimal_max'],
        low_stress_threshold: temp_data['low_stress_threshold'],
        high_stress_threshold: temp_data['high_stress_threshold'],
        frost_threshold: temp_data['frost_threshold'],
        sterility_risk_threshold: temp_data['sterility_risk_threshold'],
        max_temperature: temp_data['max_temperature']
      )
    end
    
    # Sunshine Requirement
    if stage_requirement['sunshine'].present?
      sunshine_data = stage_requirement['sunshine']
      stage.create_sunshine_requirement!(
        minimum_sunshine_hours: sunshine_data['minimum_sunshine_hours'],
        target_sunshine_hours: sunshine_data['target_sunshine_hours']
      )
    end
    
    # Thermal Requirement
    if stage_requirement['thermal'].present?
      thermal_data = stage_requirement['thermal']
      stage.create_thermal_requirement!(
        required_gdd: thermal_data['required_gdd']
      )
    end
    
    saved_count += 1
  end
  
  { count: saved_count, japanese: japanese_stages }
rescue => e
  ColorLogger.error("Failed to save stages: #{e.message}")
  { count: 0, japanese: [] }
end

# Header
ColorLogger.log("\n" + "=" * 80, :blue)
ColorLogger.log("India Reference Crops - Direct agrr Execution", :blue)
ColorLogger.log("=" * 80, :blue)
puts ""

# Get India reference crops without stages
ColorLogger.info("Searching for India reference crops without stage information...")
crops = Crop.where(is_reference: true, region: 'in').select do |c|
  c.crop_stages.count == 0
end

if crops.empty?
  ColorLogger.success("All crops already have stage information!")
  exit 0
end

ColorLogger.success("Found #{crops.count} crops without stage information")
puts ""

# Track Japanese stages
all_japanese_stages = {}

# Process each crop
crops.each_with_index do |crop, index|
  ColorLogger.log("\n[#{index + 1}/#{crops.count}] Processing: #{crop.name} (#{crop.variety})", :blue)
  
  # Fetch crop info from agrr
  ColorLogger.info("  Fetching AI information from agrr...")
  crop_info = fetch_crop_info_from_agrr(crop.name)
  
  if crop_info.nil?
    ColorLogger.warning("  Failed to fetch data (skipped)")
    next
  end
  
  crop_data = crop_info['crop']
  stage_requirements = crop_info['stage_requirements']
  
  unless stage_requirements.present?
    ColorLogger.warning("  No stage information available (skipped)")
    next
  end
  
  # Update crop basic info
  crop.update!(
    area_per_unit: crop_data['area_per_unit'],
    revenue_per_area: crop_data['revenue_per_area'],
    groups: crop_data['groups'] || []
  )
  
  # Save stages
  result = save_crop_stages(crop, stage_requirements)
  
  if result[:count] > 0
    ColorLogger.success("  Saved #{result[:count]} stages")
    
    if result[:japanese].any?
      ColorLogger.warning("  Japanese stage names detected:")
      result[:japanese].each { |name| ColorLogger.warning("    - #{name}") }
      all_japanese_stages[crop.name] = result[:japanese]
    end
  else
    ColorLogger.warning("  Failed to save stages")
  end
  
  # Reduce API load
  sleep 2 if index < crops.count - 1
end

puts ""
ColorLogger.log("=" * 80, :green)
ColorLogger.success("Completed!")
ColorLogger.log("=" * 80, :green)
puts ""

if all_japanese_stages.any?
  ColorLogger.log("⚠️  Japanese stage names detected in #{all_japanese_stages.keys.count} crops:", :yellow)
  all_japanese_stages.each do |crop_name, stages|
    puts ""
    puts "  #{crop_name}:"
    stages.each { |stage| puts "    - #{stage}" }
  end
  puts ""
  ColorLogger.info("Next step: Run translation script to convert to English")
else
  ColorLogger.success("No Japanese characters detected!")
end

puts ""
ColorLogger.info("Summary:")
puts "  Total crops processed: #{crops.count}"
puts "  Crops with Japanese stages: #{all_japanese_stages.keys.count}"
puts ""

